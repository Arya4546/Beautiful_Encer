// Prisma schema for Influencer Marketing System

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String      @id @default(uuid())
  name      String
  email     String      @unique
  password  String
  role      Role
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt @default(now()) 
  influencer Influencer? 
  salon      Salon?
  
  // Connection requests
  sentRequests     ConnectionRequest[] @relation("SentRequests")
  receivedRequests ConnectionRequest[] @relation("ReceivedRequests")
}

model Influencer {
  id              String           @id @default(uuid())
  phoneNo         String?
  emailVerified   Boolean          @default(false)
  bio             String?
  profilePic      String?
  categories      String[]
  region          String?
  age             Int?
  gender          Gender?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  user              User                @relation(fields: [userId], references: [id])
  userId            String              @unique
  socialMediaAccounts SocialMediaAccount[]
}

model Salon {
  id                  String       @id @default(uuid())
  phoneNo             String?
  emailVerified       Boolean      @default(false)
  
  // Onboarding fields
  businessName        String?      // Official business name
  description         String?      @db.Text
  profilePic          String?      // Logo/profile picture
  preferredCategories String[]     // Types of influencers they want to work with
  
  // Business details
  website             String?
  establishedYear     Int?
  teamSize            Int?         // Number of staff
  
  // Operating hours (stored as JSON string)
  operatingHours      String?      @db.Text
  
  // Social media (optional, not OAuth)
  instagramHandle     String?
  tiktokHandle        String?
  facebookPage        String?
  
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String @unique
}

model Otp {
  id        String   @id @default(uuid())
  email     String
  otp       String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@unique([email, otp])
}

model SocialMediaAccount {
  id                String              @id @default(uuid())
  platform          SocialMediaPlatform
  platformUserId    String              // Instagram/TikTok user ID
  platformUsername  String              // Display username
  accessToken       String              // Encrypted access token
  refreshToken      String?             // Encrypted refresh token (if applicable)
  tokenExpiresAt    DateTime?           // Token expiration
  isActive          Boolean             @default(true)
  
  // Cached metrics (updated periodically)
  followersCount    Int?
  followingCount    Int?
  postsCount        Int?
  engagementRate    Float?
  lastSyncedAt      DateTime?
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  influencer        Influencer          @relation(fields: [influencerId], references: [id], onDelete: Cascade)
  influencerId      String
  
  posts             SocialMediaPost[]

  @@unique([influencerId, platform])
  @@index([influencerId])
}

model SocialMediaPost {
  id                String              @id @default(uuid())
  platformPostId    String              // Original post ID from platform
  caption           String?             @db.Text
  mediaUrl          String?             // Primary media URL
  mediaType         MediaType
  likesCount        Int                 @default(0)
  commentsCount     Int                 @default(0)
  sharesCount       Int                 @default(0)
  viewsCount        Int?
  engagementRate    Float?
  postedAt          DateTime
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  socialMediaAccount SocialMediaAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId          String

  @@unique([accountId, platformPostId])
  @@index([accountId])
  @@index([postedAt])
}

model ConnectionRequest {
  id          String              @id @default(uuid())
  status      ConnectionStatus    @default(PENDING)
  message     String?             @db.Text
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // Sender (can be influencer or salon)
  senderId    String
  sender      User                @relation("SentRequests", fields: [senderId], references: [id], onDelete: Cascade)

  // Receiver (can be influencer or salon)
  receiverId  String
  receiver    User                @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@index([status])
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum Role {
  INFLUENCER
  SALON
  ADMIN
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  PREFER_NOT_TO_SAY
}

enum SocialMediaPlatform {
  INSTAGRAM
  TIKTOK
}

enum MediaType {
  IMAGE
  VIDEO
  CAROUSEL
  REEL
  STORY
}
