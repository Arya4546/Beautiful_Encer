// Prisma schema for Influencer Marketing System

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String      @id @default(uuid())
  name      String
  email     String      @unique
  password  String
  role      Role
  // Legal acceptance
  termsAccepted  Boolean   @default(false)
  termsAcceptedAt DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt @default(now()) 
  influencer Influencer? 
  salon      Salon?
  
  // Connection requests
  sentRequests     ConnectionRequest[] @relation("SentRequests")
  receivedRequests ConnectionRequest[] @relation("ReceivedRequests")
  
  // Chat
  conversations    ConversationParticipant[]
  messages         Message[]
  
  // Notifications
  notifications    Notification[]
}

model Influencer {
  id              String           @id @default(uuid())
  phoneNo         String?
  emailVerified   Boolean          @default(false)
  bio             String?
  profilePic      String?
  categories      String[]
  region          String?
  age             Int?
  gender          Gender?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  user              User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String              @unique
  socialMediaAccounts SocialMediaAccount[]
}

model Salon {
  id                  String       @id @default(uuid())
  phoneNo             String?
  emailVerified       Boolean      @default(false)
  
  // Onboarding fields
  businessName        String?      // Official business name
  description         String?      @db.Text
  profilePic          String?      // Logo/profile picture
  preferredCategories String[]     // Types of influencers they want to work with
  
  // Business details
  website             String?
  establishedYear     Int?
  teamSize            Int?         // Number of staff
  
  // Operating hours (stored as JSON string)
  operatingHours      String?      @db.Text
  
  // Social media (optional, not OAuth)
  instagramHandle     String?
  tiktokHandle        String?
  facebookPage        String?
  
  createdAt           DateTime     @default(now())
  updatedAt           DateTime     @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
}

model Otp {
  id        String   @id @default(uuid())
  email     String
  otp       String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@unique([email, otp])
}

model SocialMediaAccount {
  id                String              @id @default(uuid())
  platform          SocialMediaPlatform
  platformUserId    String              // Instagram/TikTok user ID
  platformUsername  String              // Display username
  displayName       String?             // Full name/display name
  profileUrl        String?             // Profile URL
  profilePicture    String?             // Profile picture URL
  accessToken       String              // Encrypted access token (or empty for scraping)
  refreshToken      String?             // Encrypted refresh token (if applicable)
  tokenExpiresAt    DateTime?           // Token expiration
  isActive          Boolean             @default(true)
  
  // Cached metrics (updated periodically)
  followersCount    Int?
  followingCount    Int?
  postsCount        Int?
  engagementRate    Float?
  lastSyncedAt      DateTime?
  metadata          Json?               // Additional platform-specific data
  
  // Account verification and lock
  isVerified        Boolean             @default(false) // Whether account ownership is verified
  verificationCode  String?             // Verification code for DM/bio verification
  lastAccountChange DateTime?           // Last time account was changed (for 7-day lock)
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  influencer        Influencer          @relation(fields: [influencerId], references: [id], onDelete: Cascade)
  influencerId      String
  
  posts             SocialMediaPost[]

  @@unique([influencerId, platform])
  @@index([influencerId])
}

model SocialMediaPost {
  id                String              @id @default(uuid())
  platformPostId    String              // Original post ID from platform
  caption           String?             @db.Text
  mediaUrl          String?             // Primary media URL
  mediaType         MediaType
  likesCount        Int                 @default(0)
  commentsCount     Int                 @default(0)
  sharesCount       Int                 @default(0)
  viewsCount        Int?
  engagementRate    Float?
  postedAt          DateTime
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  socialMediaAccount SocialMediaAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  accountId          String

  @@unique([accountId, platformPostId])
  @@index([accountId])
  @@index([postedAt])
}

model ConnectionRequest {
  id          String              @id @default(uuid())
  status      ConnectionStatus    @default(PENDING)
  message     String?             @db.Text
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt

  // Sender (can be influencer or salon)
  senderId    String
  sender      User                @relation("SentRequests", fields: [senderId], references: [id], onDelete: Cascade)

  // Receiver (can be influencer or salon)
  receiverId  String
  receiver    User                @relation("ReceivedRequests", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([senderId, receiverId])
  @@index([senderId])
  @@index([receiverId])
  @@index([status])
}

// Chat system models
model Conversation {
  id          String                    @id @default(uuid())
  createdAt   DateTime                  @default(now())
  updatedAt   DateTime                  @updatedAt
  
  // Last message for quick access
  lastMessageAt DateTime?
  lastMessage   String?                 @db.Text
  
  participants ConversationParticipant[]
  messages     Message[]

  @@index([lastMessageAt])
}

model ConversationParticipant {
  id             String       @id @default(uuid())
  conversationId String
  userId         String
  joinedAt       DateTime     @default(now())
  
  // For unread count
  lastReadAt     DateTime?
  
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([userId])
  @@index([conversationId])
}

model Message {
  id             String       @id @default(uuid())
  conversationId String
  senderId       String
  content        String       @db.Text
  messageType    MessageType  @default(TEXT)
  
  // For file/image messages
  fileUrl        String?
  fileName       String?
  fileSize       Int?
  
  // Message status
  isEdited       Boolean      @default(false)
  isDeleted      Boolean      @default(false)
  deletedAt      DateTime?
  
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([senderId])
  @@index([createdAt])
}

model Notification {
  id          String           @id @default(uuid())
  type        NotificationType
  title       String
  message     String           @db.Text
  isRead      Boolean          @default(false)
  
  // Reference IDs for different notification types
  connectionRequestId String?
  messageId           String?
  conversationId      String?
  
  // Metadata as JSON
  metadata    String?          @db.Text
  
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt
  
  // User who receives the notification
  userId      String
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
}

model ActivityLog {
  id          String           @id @default(uuid())
  action      ActivityAction
  description String           @db.Text
  
  // Admin who performed the action
  adminId     String
  adminName   String
  adminEmail  String
  
  // Target user (if applicable)
  targetUserId String?
  targetUserName String?
  targetUserEmail String?
  
  // IP address and user agent
  ipAddress   String?
  userAgent   String?
  
  // Metadata as JSON
  metadata    String?          @db.Text
  
  createdAt   DateTime         @default(now())
  
  @@index([adminId])
  @@index([targetUserId])
  @@index([action])
  @@index([createdAt])
}

enum NotificationType {
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
  CONNECTION_REJECTED
  NEW_MESSAGE
  MESSAGE_REPLY
  PROFILE_VIEW
  SYSTEM
}

enum ActivityAction {
  USER_SUSPENDED
  USER_ACTIVATED
  USER_DELETED
  PASSWORD_RESET
  CONNECTION_DELETED
  MESSAGE_DELETED
  USER_VIEWED
  NOTIFICATION_SENT
  SYSTEM_SETTINGS_UPDATED
}

enum ConnectionStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum Role {
  INFLUENCER
  SALON
  ADMIN
}

enum Gender {
  MALE
  FEMALE
  NON_BINARY
  PREFER_NOT_TO_SAY
}

enum SocialMediaPlatform {
  INSTAGRAM
  TIKTOK
}

enum MediaType {
  IMAGE
  VIDEO
  CAROUSEL
  REEL
  STORY
}

enum MessageType {
  TEXT
  IMAGE
  FILE
}
